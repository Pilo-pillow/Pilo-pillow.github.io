---
title: LEETCODE.162.寻找峰值
author: Pillow
tags:
  - 二分
categories:
  - 算法
abbrlink: 3758456082
date: 2023-02-08 20:39:00
---
# LEETCODE.162.寻找峰值

## 题目

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

## 示例

~~~
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
~~~

~~~
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
~~~



## 题解

题目中的`O(log n)`是对二分的强烈暗示，那，可以用二分吗？

二分的精髓在于：根据已知信息尽多折叠搜索空间，减少搜索次数，提高穷举效率，快速找到目标。

我们知道的信息有整数数组`nums`、`nums[-1] = nums[n] = -∞`、包含一个峰值，返回任何一个即可。

那么，只要一个数相邻有比他大的数，那么这个数就不可能是峰值，由于`nums[-1] = nums[n] = -∞`，所以峰值必定在比这个数大的相邻数的那一侧，可以根据此来做判断用于折叠空间。

根据此说法，数组中间的数值要与相邻的数进行比较，然后将搜索空间缩小到比数组中间的数值大的相邻数的那一半，不断缩小得出答案。

~~~Java
public int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid + 1] > nums[mid]) left = mid + 1;
            else right = mid;
        }
        return left;//此处return right;同样正确
    }
~~~



## 拓展

之前做过的二分题目多数是`[单调性]`（递增、递减、非递增、非递减），但是这并不是二分的本质。

据本题，单调性的一定可以二分，但是二分不一定有单调性，二分的本质是**边界**，即存在一个边界，使得在一边区间不满足，另一区间满足或者反过来。

也就是`[二段性]`，当然根据题目条件，即使一边区间满足，另一边区间可能满足，也是可以使用二分的，本题也就是个例证。