title: LEETCODE.121.买股票的最佳时机
author: Pillow
tags:
  - 动态规划
category:
  - 算法
abbrlink: 3043647693
date: 2023-01-05 10:00:00
---
# LEETCODE.121.买股票的最佳时机

## 题目

给定一个数组`prices`，它的第`i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

## 示例

~~~
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
~~~

~~~
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
~~~

## 题解

### 最佳效率解法

要想保证效率，一定是仅循环一遍股票价格求出结果最佳

当遍历到第`i`天的时候，我们能够做什么？买入股票、卖出股票以及等待

那么判断买入股票和卖出股票以及等待的标准是什么？

若是第`i`天的股票价格比第`i-1`天的股票价格低，很明显第`i`天更适合购入股票，不妨定义变量`buy`来记录这个值

那么如何确定什么时候卖出股票呢？当利润最大的时候，由于我们仅仅遍历一遍，无法真正确定卖出时股票的价格，但是我们可以将假如卖出股票获得的利润记录下来，并实施更新其最大值，这样我们就可以得出最大利润了。

~~~Java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        // 特殊情况筛除
        if(prices == null || len == 0 || len == 1) return 0;
        // 买入股票价格的变量，定义其初始值，值为最大也可以
        int buy = prices[0];
        // 利润变量，初始值为0
        int res = 0;
        for(int price : prices) {
            // 更新最大利润
            res = Math.max(res, price - buy);
            // 更新买入股票价格
            if(price < buy) buy = price
        }
    }
    return res;
}
~~~

此种方法的时间复杂度和空间复杂度都达到了最低，分别为O(n)和O(1)

### 动态规划

动态规划的本质：穷举**`[状态]`**，在其中选择出最优解。穷举**`[状态]`**的目的是根据对应的**`[选择]`**更新状态。

此题的**`[状态]`**种类有两个，一个是**天数**，一个是当前的**持有状态**。

此题的**`[选择]`**有三种——**买入**、**卖出**和**等待**。

对于状态我们只需要一个二维数组即可展示出来：

~~~
dp[n][2]
例如:
dp[3][0]表示：第三天没有持有股票
dp[5][1]表示：第五天持有股票
~~~

然后根据**`[状态]`**做出**`[选择]`**更新状态

~~~
for i from 0 to n
	for s in {0 , 1}
		dp[i][s] = max(buy , sell , rest)
~~~

然后我们的最终答案就是`dp[n-1][0]`，也就是最后一天手上没有持有股票的利润

完成**`[状态]`**的穷举之后便是如何根据**`[选择]`**更新**`[状态]`**；

未持有股票0通过购买持有股票1

未持有股票0通过等待未持有股票0

持有股票1通过卖出未持有股票0

持有股票1通过等待持有股票1

之后便可以列出状态转移方程：

~~~
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
~~~

第`i`天没有持有股票，有两种可能：第`i-1`天没有持有并选择了**休息** 或 第`i-1`天持有股票并选择了**卖出**，从这两种可能中求出最大利润。

以及

~~~
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
~~~

第`i`天持有股票，有两种可能：第`i-1`天持有股票并选择了**休息** 或 第`i-1`天未持有股票并选择了**购买**，从这两种可能中求出最大利润。

总的来说，如果**购买**就从利润中减去`prices[i]`，如果卖出，就要给利润增加`prices[i]`，今天的最大利润应该是这两种可能中最大的那个。

最后就是定义初始状态：

~~~
dp[-1][0] = 0 			i从0开始循环，i = -1表示还没开始循环，此时利润为0
dp[-1][1] = -infinity 	 算法需要求最大值，所以初始值设置为最小值
~~~

最后对下标-1稍作处理，也就是前进一步

~~~
dp[0][0] = max(dp[-1][0], dp[-1][1] + pirces[0]) = max(0, -infinity + prices[i]) = 0;
dp[0][1] = max(dp[-1][1], dp[-1][0] - prices[0]) = max(-infinity, 0 - prices[i]) = -prices[i];
~~~

融入算法中：

~~~java
public int maxProfit(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for(int i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        // dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        // 由于只会进行一次股票购买，后续不会再从利润中扣除购买股票的钱
        // 将dp[0][0]带入化简即可
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }
    return dp[n - 1][0];
}
~~~

## 拓展

`LEETCODE.122.买卖股票的最佳时期Ⅱ`添加可无限次购买卖出股票，将上述`dp[i-1][0] - prices[i]`添加上即可

`LEETCODE.123.买卖股票的最佳时期Ⅲ`添加仅购买卖出两次股票的条件，添加**购买次数**的**`[状态]`**种类，带入到算法框架中即可

`LEETCODE.188.买卖股票的最佳时期Ⅳ`、`LEETCODE.309.买卖股票的最佳时机含冷冻期`、`LEETCODE.714.买卖股票的最佳时机含手续费`都可带入此框架中解决