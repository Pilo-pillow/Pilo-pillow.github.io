---
title: 快速排序详解
author: Pillow
tags:
  - 快速排序
categories:
  - 算法
abbrlink: 866226008
date: 2023-02-19 17:20:00
---
# 快速排序详解

> 有问题欢迎提出

## 引入

排序是个很耐思考的事情

比如体育课上老师给我们排位置，为了尽量让所有的学生能够看到老师的动作，需要将个子低的排在前面，个子高的排在后面，那么高高低低的学生站成一堆，如何排序呢？

先换个思路，如果已经整理好了一个由低到高的队伍，突然来了一个插班生，如何找到他的正确位置呢？他会从队首走到队尾找位置，直到这个位置前面的同学比自己低，后面的同学比自己高。

那么在一个无序的队伍中，我们可以随便找一个学生A出来，将他与其他同学一个一个比较，比他低的同学排在一个低队伍，比他高的同学排成一个高队伍，然后将A插在低队伍和高队伍之间，此时A前面的同学都比自己低，后面的同学都比自己高，不用管其他同学的位置怎样，同学A的位置就已经是正确的了。之后再对高队伍和低队伍也找个同学执行同样的操作，最后所有同学都在正确的位置上，排队伍的工作就完成了。

## 简要

排队伍的栗子就是基本的快速排序。

快速排序基本思想是：通过判断、交换和递归将各个元素放在集合中正确的位置以完成排序。

快速排序是冒泡排序的优化，其优点在于快排遍历更少，所做的交换更具有意义，也更少。

快速排序使用了分治的思想，将一个复杂问题不断分成多个相同或类似的子问题，直到最小的子问题得到解决，复杂问题也随之解决。

## 详解

以下是对方法用处的简要说明，便于快速带入理解：

* `quickSort`：快排，对数组排序的方法
* `paritition`：分区，找到一个元素的正确位置，同时确定分治（递归）的边界
* `swap`：交换，交换数组内两个位置的元素
* *`quickSelect`*：快速选择

以下是对变量名称的简要说明：

* `nums`：需排序的数组

* `left`：需要排序数组的左边界
* `right`：需要排序数组的右边界
* `leftPoint`：数组中位于左侧的指针，含义根据以下不同快排有所不同
* `rightPoint`：数组中位于右侧的指针
* `pivot`：基准值
* *`middle`*：三路快排的中间指针

快速排序的整体框架如下，其各类别会因为不同的需求对`partition`方法做出调整。

~~~
class quickSort {
    public void quickSort(int[] nums, int left, int right) {
        if (left >= right) return;
        int pivotIndex = paritition(nums, left, right);
        quickSort(nums, left, pivotIndex - 1);
        quickSort(nums, pivotIndex + 1, right);
    }

    private int paritition(int[] nums, int left, int right) {
    // get num the right index
    }

    private void swap(int[] nums, int x, int y) {
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }
}

~~~



### 基本快排

初始化：

~~~
leftPoint = left;
rightPoint = left + 1;
pivot = nums[left];
~~~

我们使用`rightPoint`遍历`[left, right]`区间除了`pivot`的所有的数，遇到小于`pivot`的数时，先让`left++`指向下个数，然后交换`left`和`right`所指数的位置，使得小数在前；遇到大于`pivot`的数跳过，直到`rightPoint > right`结束此次寻找。

此时`left`所在得位置即是`pivot`的正确位置，与`left`交换返回即可。

~~~Java
private int paritition(int[] nums, int left, int right) {
    int pivot = nums[left];
    int leftPoint = left;
    int rightPoint = left + 1;
    for (; rightPoint <= right; rightPoint++)
        if (nums[rightPoint] < pivot)
            swap(nums, rightPoint, ++leftPoint);
    swap(nums, leftPoint, left);
    return leftPoint;
}
~~~

*也可以初始化`leftPoint == left + 1`，提前指向下一位置（比基准值小的区间的下一个值），在与`rightPoint`交换后再+1，循环结束基准值的正确位置为`leftPoint - 1`。*

~~~Java
private int paritition(int[] nums, int left, int right) {
    int pivot = nums[left];
    int leftPoint = left + 1;
    int rightPoint = left + 1;
    for (; rightPoint <= right; rightPoint++)
        if (nums[rightPoint] < pivot)
            swap(nums, rightPoint, leftPoint++);
    swap(nums, leftPoint - 1, left);
    return leftPoint - 1;
}
~~~

### 随机快排

当数组趋于有序时，例如`{1,2,3,4,5,6,7,9,8}`。

使用基本快排会先遍历1右边所有的数确定1的位置，然后遍历2右边所有的数确定2的位置……每次排定的基准值左侧无数值，此时的递归基本名存实亡了，最后时间复杂度由原来的`O(nlogn)`坍缩为`O(n^2)`。

所以我们引入随机基准数。

在每次使用`left`确定基准数的之前，将`left`与右方随机一个元素交换位置，然后再找随机基准值的正确位置，此时递归便可如期成立，利用空间换取时间。

~~~Java
private int paritition1(int[] nums, int left, int right) {
    Random random = new Random(System.currentTimeMillis());
    int randomIndex = left + random.nextInt(right - left + 1);
    swap(nums, left, randomIndex);
    int pivot = nums[left];
    int leftPoint = left;
    int rightPoint = left + 1;
    for (; rightPoint <= right; rightPoint++)
        if (nums[rightPoint] < pivot)
            swap(nums, rightPoint, ++leftPoint);
    swap(nums, leftPoint, left);
    return leftPoint;
}
~~~

### 双路随机快排

当数组有很多相同元素的时候，例如`{1，2，2，2，2，2，2，2，2，1，3}`，即使引入了随机基准数，在进行判定时

无论是`if (nums[rightPoint] < pivot)`

还是`if (nums[rightPoint] > pivot)`

都会造成比基准值大的区间·或者·小的区间·元素过多，从而无法有效使递归提高效率。

为了解决问题，引入了双路查找（叫法不统一，理解即可），在查找大小两区间的数时不再仅从一边寻找，而是从两边开始，在左右两个指针不构成合理区间时再将基准值放在正确位置，这样就可以让相等的元素平均地分布在基准值的两侧，保证了递归平衡。

此时，初始化：

~~~
leftPoint = left + 1;
rightPoint = right;
~~~

使`leftPoint`从左向右不断找比基准值大的数

使`rightPoint`从右向左不断找比基准值小的数

然后两者交换，直到不满足`leftPoint <= rightPoint`时，交换`left`和`leftPoint`的值。

~~~java
private int partition4(int[] nums, int left, int right) {
    Random random = new Random(System.currentTimeMillis());
    int randomIndex = left + random.nextInt(right - left + 1);
    swap(nums, left, randomIndex);
    int pivot = nums[left];
    int leftPoint = left + 1;
    int rightPoint = right;
    while (leftPoint <= rightPoint) {
        while (leftPoint <= rightPoint && nums[leftPoint] < pivot) leftPoint++;
        while (leftPoint <= rightPoint && nums[rightPoint] > pivot) rightPoint--;
        if (leftPoint < rightPoint) swap(nums, leftPoint, rightPoint);
    }
    swap(nums, left, leftPoint - 1);
    return leftPoint - 1;
}
~~~

### 三路快排

`leftPoint`和`rightPoint`的初始化和作用和双路快排相同

添加一个`middle`变量用于从`left + 1`向右遍历元素直至`middle > rightPoint`

~~~java
private int partition5(int[] nums, int left, int right) {
    Random random = new Random(System.currentTimeMillis());
    int randomIndex = left + random.nextInt(right - left + 1);
    swap(nums, left, randomIndex);
    int pivot = nums[left];
    int leftPoint = left + 1;
    int rightPoint = right;
    int middle = left + 1;
    while (middle <= rightPoint) {
        if (nums[middle] < pivot)
            swap(nums, middle++, leftPoint++);
        else if (nums[middle] > pivot)
            swap(nums, middle, rightPoint--);
        else middle++;
    }
    swap(nums, left, leftPoint - 1);
    return leftPoint - 1;
}
~~~

## 拓展

### 快速选择

快速选择是快排的一个使用方法，经常用于查找。

基本思想是根据条件仅选择一段区间进行遍历，从而提高效率。

详细的内容带入题解比较容易理解 [LEETCODE.215.数组中的第K个最大元素](https://pillow-blog.top/undefined/3879140556.html)

### 递归不平衡

也就是上面提到的基本快速选择的弊端，基准值正确位置的两边区间元素数量差距巨大，导致递归不平衡，使得时间复杂度坍缩。