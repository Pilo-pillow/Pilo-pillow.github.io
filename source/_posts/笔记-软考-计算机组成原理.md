---
title: 笔记.软考.计算机组成原理
author: Pillow
tags:
  - 软考
categories:
  - 笔记
abbrlink: 3598802677
date: 2023-04-02 11:27:00
mathjax: true
---
# 计算机组成与体系结构

## 数据的表示

### 进制转换

#### R进制转十进制

按权展开法

~~~
二进制10100.01=1*2^4+1*2^2+1*2^-2
~~~

~~~
R进制AB.CD = A*R^1+B*R^0+C*R^-1+D*R^-2
~~~

#### 十进制转R进制

短除法

将十进制数不断先对2取余后整除2，得到的一个个余数反序得到的就是二级制数。

#### 二进制转八进制与十六进制

二级制数从右向左分段，八进制三位一段转为八进制数，十六机制四位一段转为十六进制数，最后各段拼接起来即可

### 原码反码补码

#### 机器数

即在计算机中以二进制表示形式的数，机器数最高位存放符号，表示正负，正数为0，负数为1

比如十进制的+9，计算机字长8位，则表示为0000 1001，-9则为1000 1001

#### 机器数的真值

由于最高位是符号值，机器数的形式值不等于真正数值，1000 1001真值为-9，而不是十进制的137

将带符号的机器数对应的真正数值称之为机器数的真值。

> 原码、反码、补码是及其存储一个具体数字的编码方式

#### 原码

即符号位加上真值的绝对值，即第一位表示符号，其余位表示值

`原[1111 1111, 0111 1111] = 真值[-127, 127]`

#### 反码

正数的反码为其本身，负数的反码是在其原码的基础上，符号位不变，其余各位取反。

`原[0000 0001, 1000 0001] = 反[0000 0001, 1111 1110] = 真值[+1, -1]`

#### 补码

正数的补码就是其本身，负数的补码是在原码的基础上，符号位不变，其余各位取反后+1。

`原[0000 0001, 1000 0001] = 反[0000 0001, 1111 1110] = 补[0000 0001, 1111 1111] = 真值[+1, -1]`

#### 原因

人脑可以很轻易的理解符号位，然后进行运算，但是要让计算机辨别符号位会让基础电路的设计十分复杂。

*计算机更适合做单一的工作，统一使用机器值运算，且各种运算都可用加法表示*，最佳为：

将符号位参与运算，并且只保留加法

##### 使用原码计算

`1 - 1 = 1 + (-1) = 原[0000 0001]+ 原[1000 0001] = 原[1000 0010] = -2`

发现参与到负数的运算，也就是减法的运算，结果是不正确的

##### 使用反码计算

`1 - 1 = 1 + (-1) = 原[0000 0001] + 原[1000 0001] = 反[0000 0001] + 反[1111 1110] = 反[1111 1111] = 原[1000 0000] = -0`

0和-0对人来讲很好理解，对与计算机来说是两个东西，两个不同的东西表示同一个意义，显然不合理。

##### 使用补码计算

`1 - 1 = 1 + (-1) = 原[0000 0001] + 原[1000 0001] = 补[0000 0001] + 补[1111 1111] = 补[1 0000 0000] = 补[0000 0000] = 原[0000 0000]`

补码可以用[1000 0000]表示-128：

`(-1) + (-127) = 原[1000 0001] + 原[1111 1111] = 补[1111 1111] + 补[1000 0001] = 补[1000 0000] `

使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为`[-127, +127]`，而使用补码表示的范围为`[-128, 127]`。

#### 深入

[原码、反码、补码 详解！](https://mp.weixin.qq.com/s?__biz=MzI0OTQwNDQxMw==&mid=2247483760&idx=1&sn=27cbdd41da43b5b71c9f7a3ae807fae6&chksm=e9934fe2dee4c6f4869f6d46004c2f3a76c3b5aefc1d1acc8acd9504c64e9a8143f21fe2c968&scene=27)

#### 浮点数运算

定点数就是小数点位置约定不变的的数，浮点数与之相对应，小数点的位置是漂浮不定的。

浮点数表示为`V = (-1)^S * M * R^e`

* S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负
* M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数
* R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2
* e：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数，或者称之为**阶码**

浮点数的运算过程为：

对阶——尾数计算——结果格式化

对阶：就是将阶码小的向阶码大的浮点数转换

尾数计算：经过对阶后，两浮点数的尾数可进行运算

结果格式化：以科学计数法表示结果

~~~
3.334*10^3+6.1*10^4 计算过程：
对阶：0.3334*10^4+6.1*10^4
尾数计算：6.4334*10^4
结果格式化：6.4334*10^4
~~~

## 计算机结构

计算机整体分为内设和外设，外设就是硬盘显卡声卡显示器之类的，内设指计算机主机

主机的结构主体结构为：

* 主存储器
* CPU
  * 运算器：执行运算职能
    1. 算术逻辑单元ALU
    2. 累加寄存器AC
    3. 数据缓存寄存器DR
    4. **状态条件寄存器PSW**
  * 控制器：执行控制职能
    1. 程序计数器PC
    2. 指令寄存器IR
    3. 指令译码器
    4. 时序部件

### Flynn分类法

计算机分类法，分类依据有数据流和指令流——单指令、多指令和单数据流、多指令流交叉为四个体系结构类型：

* 单指令流单数据流（SISD）：指令部件每次只对一条指令进行译码，并只对一个操作部件分配数据，常用于单片机这类简单机械中。(单处理系统)
* 单指令多数据流（SIMD）：并行处理机为代表，并行处理机包括多个重复的处理单元，由单一指令部件控制，按照同一指令流的要求为他们分配不同数据。(并行处理器，阵列处理器，超级向量处理器)
* 多指令流单数据流（MISD）：n个处理单元按照n条不同指令对同一数据及其中间结果做出不同的处理，有理论模型，意义不大，实际中并无应用。
* 多指令多数据流（MIMD）：全面并行的多机系统  例如Intel的双核处理器（多处理器系统，多计算机）

其中：`M:Multiple`  `I:Instruction`  `S:Single`  `D:Data` 

### CISC与RISC

计算机指令集

![image-20230329155135925](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/image-20230329155135925.png)

#### 复杂指令系统计算机（CISC）

随着VLSI技术的发展，硬件成本下降，软件成本上升，促使人们在指令系统中增加更多、更复杂的指令。

主要特点：

1. 指令系统庞大复杂，指令数目在20条以上。
2. 指令的长度不固定，[指令格式](https://www.zhihu.com/search?q=指令格式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})多，[寻址方式](https://www.zhihu.com/search?q=寻址方式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})多。
3. 可以访存的指令不受限制。
4. 各种指令执行时间相差很大，大部分指令需要多个时钟时期才能完成。
5. 控制器大多采用[微程序控制](https://www.zhihu.com/search?q=微程序控制&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})，有些指令非常复杂，以至于无法采用[硬连线控制](https://www.zhihu.com/search?q=硬连线控制&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})。
6. 难以用优化编译生成高效的目标代码程序。

#### 精简指令系统计算机（RISC）

中心思想：要求指令系统简化，尽量采用寄存器-寄存器操作指令，指令格式力求一致。

主要特点：

1. 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现
2. 指令长度固定，指令格式种类少，寻址方式种类少
3. 只有Load/Store（取数/存数）指令访存，其余指令都在寄存器之间进行
4. CPU中[通用寄存器](https://www.zhihu.com/search?q=通用寄存器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})的数量相当多
5. RISC一定采用[指令流水线技术](https://www.zhihu.com/search?q=指令流水线技术&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})，大部分指令的操作都在一个[时钟周期](https://www.zhihu.com/search?q=时钟周期&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})内完成
6. 以硬布线控制为主，不用或少用微程序控制
7. 特别重视编译优化工作，以减少程序执行时间

CISC兼容性更好。

#### CISC和RISC的比较

与CISC相比RISC的优点：

1. 更能充分利用VLSI芯片的面积
2. 有更高的运算速度
3. 便于设计，可降低成本，提高可靠性
4. 有利于[编译程序](https://www.zhihu.com/search?q=编译程序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2623293708})代码的优化

对比表：

|                  | CISC                                 | RISC                                 |
| ---------------- | ------------------------------------ | ------------------------------------ |
| 指令系统         | 复杂，庞大                           | 简单，精简                           |
| 指令数目         | 一般大于200条                        | 一般小于100条                        |
| 指令字长         | 不固定                               | 固定                                 |
| 可访存指令       | 不加限制                             | 只有Load/Store指令                   |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量   | 较少                                 | 多                                   |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
| 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |

BY 三点四刻-知乎

## 流水线技术

并行和并发是不同的

**并行**指的是：两个或两个以上的事件在**同一时刻**发生。

**并发**指的是：两个或两个以上的事件在**同一时间间隔**发生。

流水线主要实现了并行技术

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。

| 取指 |  1   |  2   |  3   |  .   |  .   |  .   |  n   |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 分析 |      |  1   |  2   |  3   |  .   |  .   |  .   |  n   |      |
| 执行 |      |      |  1   |  2   |  3   |  .   |  .   |  .   |  n   |

### 流水线计算

若指令流水线把一条指令分为取指、分析和执行三个部分，时长分别为`2ns`、`2ns`、`1ns`，求流水线周期和100条指令全部执行完毕需要的时间。

**流水线周期为执行时间最长的一段**

### 流水线计算公式

一条指令执行时间+（指令条数-1）

流水线周期
理论公式：`（t¹+t²+t³+…+tⁿ）+（x-1）∆t`
时间公式：`（n+x-1）∆t`

理论计算为：`2+2+1+2*(100-1)=203`

实际计算为：`2+2+2+2*(100-1)=204`

> 理论中，第一个产品完成后，第二个产品进入到第三个工序，直到最后一个产品，所以相当于两个第一个产品需要前两个工序用于准备生产，也就是
>
> `1+2+2*(1+100-1)=1+2+2+2*(100-1)`
>
> 而实际当中，`1ns`的工序会有`1ns`的空窗期，实际需要耗时为`2ns`最后是
>
> `（3+100-1）*2=104`

### 流水线吞吐率计算

吞吐率是指单位时间内流水线完成的任务数量或输出的结果数量


$$
TP=\frac{指令条数}{流水线执行时间}
$$


本例题中：`TP=100/103`

### 流水线最大吞吐率


$$
TP_{max}={\lim_{n\to+\infty}}\frac{n}{(k+n-1)\bigtriangleup t}=\frac{1}{\bigtriangleup t}
$$


### 流水线加速比

完成同样一批任务，不使用流水线所用的时间与使用流水线所用时间之比称为流水线的加速比。


$$
S=\frac{不使用流水线执行时间}{使用流水线执行时间}
$$


本例题：不适用流水线执行时间为`(2+2+1)*100=500`

流水线加速比为：`203/500`

### 流水线效率

流水线的效率是指流水线的设备利用率：流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比，在时空图上表现为
$$
流水线效率=\frac{被占用的时空格}{总的时空格}
$$
例如有100条执行，每条指令取值`3ns`，分析`4ns`，执行`1ns`。

**总的时空格 = 指令工序数 x 指令全部的执行时间 = 3 x 404 = 1212**

**被占用的时空格 = （3 + 4 + 1） \* 100 = 800**

所以流水线效率 = 800 / 1212

## 存储系统

### 层次化存储结构

![存储结构概论](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/36b214095b534a6984b81de8401aaab7.png)

* 寄存器：CPU 的寄存器一般在运算器和控制器中，作为一个临时缓存，一般的寄存器存储容量只有 1 - 64 KB 个大小。
* 高速缓存：又称 Cache，速度位于寄存器和内存之间，CPU 的寄存器在取指令操作时，先到 Cache 中查询，若有则直接返回，若没有才会到内存中读取，Cache 的存在可以加快 CPU 的执行效率，一般以 MB 作为计量单位。
* 内存：是计算机的运行内存，现代计算机的内存容量一般在`4G - 32G`范围内。
* 外存：是计算机系统的外部存储设备，如硬盘、U 盘等，现代外存的容量一般以 TB 作为计算单位。

### Cache

Cache的功能：提高CPU数据输入输出的速率，突破CPU与存储系统间数据传送带宽限制。

在计算机的存储系统体系中，Cache是访问速度最快的层次。

使用Cache改善系统性能的依据是程序的局部性原理

#### 局部性原理

帕累托法则：20％的人口掌握了80％的社会财富。

那么如果进行征税，主要针对的应该是这20%的人，而非另外80%的人，这是一种社会资源的局部性，在计算机里也存在这类局部性。

##### 时间局部性

比如编程中的循环程序

~~~Java
int count = 0; // 只执行了一次
for (int i = 0; i <= 10; i++) {
    count += i; // 执行了10次
}
~~~

时间局部性：**如果一个信息项正在被访问，那么在近期它很可能还会被再次访问**。

##### 空间局部性

数组初始化

~~~Java
int[] array = new int[100];
for (int i = 0; i < 100; i++) {
    array[i] = i + 1;
}
~~~

数组是一段连续的内存空间，如果能够缓存当前数组地址，便可以解决重复遍历问题，偏移公式。

#### 根据Cache的命中率计算系统运行周期

假设 Cache 的命中率为 X，不用 Cache （没有命中）的周期时间为 A，用了 Cache（命中）的周期时间为 B，那么使用 `Cache + 内存模式` 的系统平均周期为多少？
$$
系统平均周期 = X\times A+(1-X)\times B
$$

### 主存

#### 主存概念

主存分为两类：随机存取存储器、只读存储器

随机存取存储器：关闭计算机时数据清空

* DRAM（Dynamic RAM，动态RAM）-SDRAM
* SRAM（Static RAM，静态RAM）

只读存储器：关闭计算机时数据保存

* MROM（Mask ROM，掩模式ROM）
* PROM（Programmable ROM，一次可编程ROM）
* EPROM（Erasable PROM，可擦除的PROM）
* 闪速存储器（flash memory，闪存）

简而言之：

`随机存取存储器` 还可以分为静态和动态，静态的是 SRAM，动态的是 DRAM。

`只读存储器` 包括磁盘，但不包括固态硬盘。

#### 地址单元的计算

$$
地址单元=尾地址-首地址+1
$$

ep1：首地址为2，尾地址为18，那么这块内存包含了`18-2+1=17`个地址单元

ep2：首地址是`BA235H`，尾地址是`BC954H`，求包含的地址单元个数。
$$
\begin{align*}\label{2}
&BC954H-BA235H\\&=
02719H\\&=
9\times16^0+1\times16^1+7\times16^2+2\times16^3\\&=
9+16+1792+8192\\&=
10009
\end{align*}
$$
ep3：如果该内存一共有1000K个地址单元，按字节编址（16位），由28片存储器芯片构成，已知每片芯片由36K个，则每块芯片的每个存储单元存储几位？
$$
存储单元位数=28\times 36K/16/1000K
$$
即
$$
1000K\times16=28\times36K\times存储单元位数
$$
ep4：内存地址从AC000H到C7FFFH，共有多少K个地址单元，如果该内存地址按字（16bit）编制，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每个存储单元存储多少位？

首先内存地址的后缀代表的意义分别为：

* B：二进制
* O：八进制（为了和“0”区分，通常记为Q）
* D：十进制（默认）
* H：十六进制

$$
\begin{align*}
&C7FFFH-AC000H+1\\&=
C8000H-AC000H\\&=
1B000H\\&=110592
\end{align*}
$$

$$
110592\times16=16000\times28\times存储单元位数\\
存储单元位数=\frac{110592\times16}{16000\times28}\approx4
$$

### 磁盘

#### 概念

磁盘就是个盘！

磁盘的物理结构由外到内分别为扇区、磁道和空

![磁盘的物理结构](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/542234e2a41c4f92a236a31f3745e975.png)

`磁盘存取时间`：磁盘进行一次数据存储消耗的时间
$$
磁盘存取时间\left\{\begin{matrix}
  寻道时间\\
  等待时间
\end{matrix}\right.
$$
`寻道时间` 指的是磁头移动到磁道所需的时间

`等待时间` 指的是等待扇区转到磁道所用的时间

#### 磁盘存取时间计算

ep1：

![磁盘的存取时间计算](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/e36caf11821345f2a59a6070a78a96fc.png)

如果磁盘的旋转周期为 25 毫秒，磁头处于 R0 的开始处。若系统采用单缓冲区处理这些记录，每个记录的处理时间为 6 毫秒，则处理这5 个记录的最长时间为多少毫秒？

每个刺刀的读取时间为`25/5=5ms`

磁头并不会因为处理数据而停下

磁头在`R0`开始处，`R0`扫描完成耗时`5ms`，`R0`处理完成耗时`6ms`，此时磁头在`R2`的`1/5`处，直到`R1`开始处，才开始`R1`的扫描和处理，如此累加时间为`(5+25)*5=150`

ep2：

> 假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R0 ，R1，… R9，R10存放在同一个磁道上，记录的存放顺序如下表所示：
>
> 物理块	1	2	3	4	5	6	7	8	9	10	11
> 逻辑记录	R0	R1	R2	R3	R4	R5	R6	R7	R8	R9	R10
> 如果磁盘的旋转周期为 33 ms , 磁头当前处在R0的开始处。若系统使用的单缓冲区顺序处理这些记录，每个记录处理时间为 3 ms , 则处理这11个记录的最长时间为 
>
> _ (1)_ ;若对信息存储进行优化分布后，处理11个记录的最少时间为 _ (2)_。
>
> （1）A. 33ms B. 336ms C. 366ms D. 376ms
>
> （2）A. 33ms B. 66ms   C. 86ms   D. 93ms

每磁道读取时间为`33/11=3ms`，处理时间为`3ms`

扫描R0用3ms，处理R0用3ms，然后等待磁头到达R1开始处用33ms，然后进行R1的扫描处理，直到R10处理完成，此时用时`(33+3)*10ms`，磁头到达R11开始处，R11扫描用时3ms，处理用时3ms，一共用时`(33+3)*10+6=366ms`

若是对信息存储优化分布后，每块磁道的扫描和处理时间均为3ms，最后获得时间为`(3+3)*11=66ms`

## 总线系统

* 计算机总线
  * 内部总线：寄存器之间的连接、芯片内部的连接、寄存器和运算器/控制器之间的连接
  * 系统总线：CPU、内存之间的连接
    * 数据总线：双向传输，和机器字长、存储字长有关
    * 地址总线：单线传输，和存储地址、I/O地址有关
    * 控制总线：用于发出信号（存储器读、存储器写、总线允许、中断确认），接受信号（中断请求、总线请求等操作）
  * 外部总线：主机和鼠标、键盘、麦克风等外部设备的连接

## 可靠性与检验码

### 可靠性

从机器开始运行时间（t=0）到某时刻t这段时间内能正常运行的概率称为系统可靠性，通常用`R(t)`表示。

系统可靠性分析的计算分为**串联**和**并联**，对应有不同的计算公式

#### 串联

![串联系统](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/f7b57760bf49425c8ee02a2d0994091a.png)

串联系统可靠性计算公式为：
$$
R=R1\times R2\times R3\times R4\times\cdots\times Rn
$$

#### 并联

![并联系统](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/2b822fb2e29f4c598da9c7ce70d235eb.png)

并联系统可靠性计算公式为：
$$
R=1-(1-R1)\times(1-R2)\times(1-R3)\times\cdots\times(1-Rn)
$$

#### 混合系统

![image-20230402084637357](https://pillow-blog-pictures.oss-cn-shanghai.aliyuncs.com/image-20230402084637357.png)

此系统整体为串联，某串联一处计算并联，计算：
$$
R_0=R\times(1-(1-R)^3)\times(1-(1-R)^2)
$$

### 校验码

检错：从接受的报文中检查出错误

纠错：从接受的报文中检查出错误并纠正错误，通常通过冗余信息（增大码距）来实现

码距：整个编码系统中任意两个码字的最小距离，码距越大，排错能力越好

---

发送为1，接受为0，码距为1，因0与1皆为合法编码，无法检错

发送为11，接受为01，码距为2，01为非法编码，可以检错，不知发送为11还是00，无法纠错

发送为111，接受为001，码距为3，001为非法编码，可以检错，且由于计算机出错概率小，可得出发送大概率为111，即可纠错

> 一个码组内检测出`x`个误码，要求最小码距`d`应该满足：`d>x+1`
>
> 一个码组内纠正出`y`个误码，要求最小码距`d`应该满足：`d>2y+1`

#### CRC循环校验码

**CRC 循环校验码是一个只能检错但不能纠错的校验码**

CRC循环校验码进行编码时，在数据尾部添加一串校验码，让编码后的数据和生成多项式相除且余数为零，接收方进行校验，若是余数不为零，则检错成功。

#### 海明校验码【重点】

海明码多数采用偶校验

##### 奇偶校验码

- 奇校验码: 整个校验码(有效信息位和校验位) 中 “1” 的个数为奇数
- 偶校验码: 整个校验码(有效信息位和校验位) 中 “1” 的个数为偶数

奇偶校验码添加了一个校验位，仅是一个比特的冗余信息只能够携带两种状态：对与错

所以奇偶校验码只能够检错，无法进行纠错

##### 海明校验码

海明码(Hamming Code)或者被叫做汉明码，是一个可以有多个校验位，具有检测并纠正一位代码错误的纠错码

海明码通常用于信道特性比较好的环境中，因为信道特性不好时，出现的错误通常不止一位

海明码的纠错基本思想在于将有效信息按规律分为若干组，每组对应一个校验码进行奇偶性测试，产生多位检测信息，得出出错位置，通过对错误位取反进行纠正。

想要对一段信息位采用海明码纠错，具体步骤为：

1. 计算校验码位数
2. 确定校验码位置
3. 计算校验码
4. 实现校验和纠错

###### 计算校验码位数

对于`n`个有限的信息位，将其分为`k`个组，分别进行偶校验，最终携带k个校验位，可以反映出多种状态的信息。

关键在于：

>  `n`个信息位如何分组能够在添加最少冗余信息的情况下能够做到对信息的纠错

信息位数`n`，校验位数`k`，则海明校验码位数`n+k`

`k`个校验位能够表示`2^k`种状态，最佳是：

此`2^k`种状态分别对应各个海明校验码位`n+k`个以及正确状态1个

得出不等式为:
$$
2^k\ge n+k+1
$$
通过此不等式确定我们需要添加多少个校验位，例如

4个信息位，即`n=4`，则k应该等于3，到达不等式边界，即校验位状态数刚好满足需求

于是海明校验码完成，n与k的一般关系为：

| n    | 1    | 2-4  | 5-11 | 12-26 | 25-57 | 58-120 | ……   |
| ---- | ---- | ---- | ---- | ----- | ----- | ------ | ---- |
| k    | 2    | 3    | 4    | 5     | 6     | 7      | ……   |

###### 确定校验码位置

海明校验码会插入对应的信息位，第`n`个校验码位置在第`2^(n-1)`位置。

例如：若信息数位有12个，带入上述不等式，得出校验码位数为4，位置依次是1，2，4，8，对应的二进制位置为：0001，0010，0100，1000

###### 计算校验码

将信息数据依次顺序填入剩余的信息位，然后每个海明校验码的数值会根据这些信息数据分组计算得出。

例如：（下表）

- 信息数据为01100100填入

- 对信息数据进行分组

  如P1校验码组内：0001——>0011，0101，0111，1001，1011

  即P1=0，1，0，0，0，5数进行异或处理，得出P1的值为1（奇为1，偶为0）

| 位置 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 |      |      | 0    |      | 1    | 1    | 0    |      | 0    | 1    | 0    | 0    |
| 校验 | 1    | 0    |      | 0    |      |      |      | 1    |      |      |      |      |
| 地址 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

* 最终校验码为：100011010100

###### 实现检验和纠错

将校验码所校验的位组成相应的组，在接收端对各校验位在进行逻辑异或运算，若采用偶校验，正常情况下均为0。

若发现仅仅是一个校验组中的校验结果不符，则是相应校验组中的校验码在传输中出现错误。

若是发现多组校验结果不对，则这些组中的公共数位即是出错位置，对其进行取反即可纠错。

